# 归零记录同一天处理逻辑

## 🎯 功能说明

当归零记录与其他交易记录发生在同一天时，**系统会自动将归零记录视为当天最晚发生的事件**。

---

## 📋 核心规则

### **时间判断优先级**

```
1. 首先比较日期（transaction_date）
   - 不同日期：按日期判断先后（最新的在前）
   
2. 日期相同时的特殊处理
   - 歸零記錄：自動排在該天最後面
   - 其他記錄：按創建時間（created_at）排序
   
3. 显示标记
   - 如有同天其他記錄，顯示"當天最後"標記
   - 提示用户此归零会影响同天记录
```

---

## 🎨 UI 显示效果

### **归零记录卡片（有同天记录）**

```
┌──────────────────────────────────────────────┐
│ 🔄  12/16 学期更新  [歸零記錄] [當天最後]   │
│     学期更新        今天 12/16                │
│     ℹ️ 此歸零記錄視為當天最後發生，          │
│        該天早於此的記錄不計入統計            │
│                            起始金額           │
│                              $50             │
└──────────────────────────────────────────────┘
```

---

### **归零记录卡片（无同天记录）**

```
┌──────────────────────────────────────────────┐
│ 🔄  12/16 学期更新  [歸零記錄]              │
│     学期更新        今天 12/16                │
│                            起始金額           │
│                              $50             │
└──────────────────────────────────────────────┘
```

---

## 📊 示例场景

### **场景 1：同一天有多笔记录**

**實際創建順序**（可能亂序添加）：
```
12/16 09:00  购买文具 -$50   (created_at: 09:00)
12/16 14:00  🔄 归零 $30     (created_at: 14:00)
12/16 10:00  比赛得奖 +$20   (created_at: 10:00)
12/16 16:00  QQ币 +$80       (created_at: 16:00)
```

**列表顯示順序**（自動排序後）：
```
12/16 09:00  购买文具 -$50   
12/16 10:00  比赛得奖 +$20   
12/16 16:00  QQ币 +$80       
12/16        🔄 归零 $30     ← 自動排在該天最後！標記"當天最後"
```

**显示效果**：
- ✅ 歸零記錄自動排在該天最後面
- ✅ 显示「當天最後」标记
- ✅ 显示提示："此歸零記錄視為當天最後發生，該天早於此的記錄不計入統計"

**统计结果**：
- 09:00 和 10:00 的记录不计入（在归零前）✗
- 16:00 的记录不计入（在归零前）✗
- 总收入：$0
- 总支出：$0
- 当前余额：$30（起始）= $30

---

### **场景 2：不同天没有冲突**

```
12/15 10:00  购买文具 -$50
12/16 14:00  🔄 归零 $30  ← 无"當天最後"标记
12/17 16:00  QQ币 +$80
```

**显示效果**：
- 归零记录不显示「當天最後」标记
- 无额外提示

**统计结果**：
- 12/15 的记录不计入（在归零前）
- 12/17 的记录计入（在归零后）
- 当前余额：$30 + $80 = $110

---

## ⚠️ 重要提示

### **创建归零记录时的说明**

```
ℹ️ 關於歸零記錄
• 歸零後，累計獎金將從此時間點重新開始計算
• 可以設定歸零後的起始金額（實際持有的金額）
• 事件名稱可留空，系統會自動生成「日期 + 分類標籤」
• 同一天的歸零記錄會被視為當天最晚發生的事件
• 適用於重新校準獎金金額或開始新學期
• 不會影響之前的記錄，只是改變計算起點

⚠️ 重要：
如果同一天有其他收支記錄，系統會自動將歸零記錄視為當天最後發生的，
所以該天早於歸零的記錄不會計入統計。
```

---

## 🔧 技術實現

### **1. 列表排序邏輯**

```typescript
const sortTransactions = (txs: any[]) => {
  return [...txs].sort((a, b) => {
    const aDate = new Date(a.transaction_date || a.created_at)
    const bDate = new Date(b.transaction_date || b.created_at)
    
    // 先按日期降序排列（最新的在前）
    const dateA = new Date(aDate.getFullYear(), aDate.getMonth(), aDate.getDate()).getTime()
    const dateB = new Date(bDate.getFullYear(), bDate.getMonth(), bDate.getDate()).getTime()
    
    if (dateA !== dateB) {
      return dateB - dateA // 日期不同，較新的在前
    }
    
    // 同一天的記錄
    // 如果其中一個是歸零記錄，歸零記錄排在後面
    if (a.transaction_type === 'reset' && b.transaction_type !== 'reset') {
      return 1 // a 是歸零，排在後面
    }
    if (b.transaction_type === 'reset' && a.transaction_type !== 'reset') {
      return -1 // b 是歸零，排在後面
    }
    
    // 都是歸零或都不是歸零，按創建時間排序
    return new Date(b.created_at).getTime() - new Date(a.created_at).getTime()
  })
}
```

---

### **2. 檢測同一天的記錄**

```typescript
const hasSameDayRecords = transaction.transaction_type === 'reset' && 
  filteredTransactions.some((t: any) => {
    if (t.id === transaction.id || t.transaction_type === 'reset') return false
    const tDate = new Date(t.transaction_date || t.created_at).toDateString()
    const resetDate = new Date(transaction.transaction_date || transaction.created_at).toDateString()
    return tDate === resetDate
  })
```

---

### **3. 統計計算邏輯**

```typescript
// 簡化邏輯：歸零記錄視為該天最後，只計入日期晚於歸零日期的交易
transactionsToCalculate = transactionsToCalculate.filter(t => {
  if (t.transaction_type === 'reset') return false // 排除歸零記錄本身
  
  const tDate = new Date(t.transaction_date || t.created_at)
  const tDateOnly = new Date(tDate.getFullYear(), tDate.getMonth(), tDate.getDate()).getTime()
  
  // 只計入日期晚於歸零日期的交易（同一天的全部不計入）
  return tDateOnly > resetDateOnly
})
```

---

### **4. 顯示邏輯**

```typescript
{hasSameDayRecords && (
  <>
    <span className="當天最後標記">當天最後</span>
    <p className="說明提示">
      ℹ️ 此歸零記錄視為當天最後發生，該天早於此的記錄不計入統計
    </p>
  </>
)}
```

---

## 🎯 列表顯示順序優勢

### **為什麼要自動排序？**

#### **問題**
如果按創建時間排序，歸零記錄可能出現在中間：
```
❌ 不直觀的順序（按 created_at）
12/16 09:00  购买文具 -$50   (created_at: 09:00)
12/16 14:00  🔄 归零 $30     (created_at: 14:00)  ← 在中間！
12/16 10:00  比赛得奖 +$20   (created_at: 10:00)
12/16 16:00  QQ币 +$80       (created_at: 16:00)
```

用戶會困惑："10:00 和 16:00 的記錄為什麼不計入？它們明明在歸零後面！"

---

#### **解決方案**
自動排序，歸零記錄排在該天最後：
```
✅ 直觀的順序（自動排序）
12/16 09:00  购买文具 -$50   
12/16 10:00  比赛得奖 +$20   
12/16 16:00  QQ币 +$80       
12/16        🔄 归零 $30     [當天最後]  ← 清楚！
```

用戶一眼就能理解："哦！歸零在最後，所以上面的都不計入！"

---

### **排序規則總結**

| 規則 | 說明 |
|------|------|
| 1️⃣ **日期優先** | 最新日期在最前面 |
| 2️⃣ **同天歸零最後** | 歸零記錄自動排在該天最後 |
| 3️⃣ **其他按時間** | 非歸零記錄按 created_at 排序 |

---

## 💡 設計理由

### **為什麼需要這個功能？**

#### **問題場景**
用户可能在同一天添加多筆記錄：
1. 早上记录了一些收支
2. 下午決定歸零重新開始
3. 傍晚又有新的收支

#### **混淆點**
- 用户可能不清楚同一天的归零会如何影响统计
- 不明白为什么早上的记录没有计入

#### **解決方案**
- ✅ 明確標記「當天最後」
- ✅ 顯示說明文字
- ✅ 創建時就提示這個機制

---

## 🎓 使用建議

### **建議做法**

✅ **單獨一天歸零**
```
12/15  正常記錄
12/16  🔄 歸零（單獨一天，無其他記錄）
12/17  新記錄
```
- 清晰明確
- 無混淆風險

---

### **需要注意的做法**

⚠️ **同一天混合記錄**
```
12/16 09:00  收支記錄
12/16 14:00  🔄 歸零
12/16 16:00  收支記錄
```
- 需要理解「當天最後」機制
- 09:00 的記錄會被排除
- 16:00 的記錄會被計入

---

## 📋 標記說明

| 標記 | 顏色 | 顯示條件 | 說明 |
|------|------|----------|------|
| **歸零記錄** | 藍色 | 所有归零记录 | 標識這是歸零記錄 |
| **當天最後** | 黃色 | 同天有其他記錄 | 提示會影響同天記錄 |

---

## ✅ 優勢

| 優勢 | 說明 |
|------|------|
| ✅ **清晰標識** | 一眼看出归零记录的特殊性 |
| ✅ **避免混淆** | 明確提示會影響同天記錄 |
| ✅ **用戶友好** | 不需要深入理解技術細節 |
| ✅ **即時反饋** | 在記錄列表就能看到提示 |

---

## 📂 修改的文件

| 文件 | 說明 |
|------|------|
| `AddTransactionForm.tsx` | ✅ 添加創建時的說明提示 |
| `TransactionRecords.tsx` | ✅ 添加「當天最後」標記和說明 |
| `RESET_SAME_DAY_LOGIC.md` | ✅ 完整功能說明文檔 |

---

## 🎉 總結

### **核心機制**
```
1. 列表自動排序
   歸零記錄 + 同天有其他記錄
   ↓
   歸零自動排在該天最後面
   ↓
   視覺上清晰直觀

2. 標記和提示
   同天有其他記錄
   ↓
   顯示「當天最後」標記
   ↓
   提示該天所有記錄不計入

3. 統計計算
   歸零日期確定
   ↓
   只計入日期晚於歸零的交易
   ↓
   同一天的記錄全部排除
```

### **用戶體驗優勢**
- 🎯 **視覺直觀**：歸零自動排在該天最後
- 📝 **標記清晰**：黃色標記醒目提示
- 💡 **易於理解**：列表順序 = 邏輯順序
- ✅ **無需思考**：一眼就能明白計算邏輯

---

🎊 **現在用戶可以輕鬆理解同一天歸零記錄的處理邏輯了！**
📊 **列表顯示順序與計算邏輯完全一致，直觀易懂！**

